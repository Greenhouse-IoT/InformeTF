<h3 align="center">Universidad Peruana de Ciencias Aplicadas - Ingeniería de Software - 2025-10</h3>
<div align="center">
  <img width=140 src="https://seeklogo.com/images/U/universidad-peruana-de-ciencias-aplicadas-upc-logo-B98C3A365C-seeklogo.com.png"/>
</div>
<h3 align="center">1ASI0572 - Desarrollo de Soluciones IOT</h3>
<h3 align="center">NRC: 2941</h3>
<h3 align="center">Profesor: Leon Baca, Marco Antonio</h3>
<h1 align="center">Informe de Trabajo Final</h1>
<h3 align="center">Startup: Integradis</h3>
<h3 align="center">Producto: Greenhouse</h3>

<table align="center" cellpadding="5" cellspacing="0">
  <thead>
    <tr>
      <th>Nombre</th>
      <th>Código</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Astuyauri Calderon, Jherson David</td>
      <td>U202218451</td>
    </tr>
    <tr>
    <tr>
      <td>Espinoza Rodríguez, Nicolás Antonio</td>
      <td>U202110278</td>
    </tr>
    <tr>
      <td>Galavis Du Bois, Alan Enrique</td>
      <td>U202110223</td>
    </tr>
    <tr>
      <td>Seminario Garbin, Carlo Luca</td>
      <td>U20211A475</td>
    </tr>
    <tr>
      <td>Soto Kong Requena, Andrés Eduardo</td>
      <td>U202116113</td>
    </tr>
  </tbody>
</table>

<h3 align="center">Abril del 2025</h3>

# Registro de versiones del Informe

| Versión | Fecha | Autor | Descripción de modificación |
| ------- | ----- | ----- | --------------------------- |
| 1.0     |       |       |                             |

# Project Report Collaboration Insights

### TB1

| Integrante                          | Tareas Asignadas |
| ----------------------------------- | ---------------- |
| Astuyauri Calderon, Jherson David    |                  |
| Espinoza Rodríguez, Nicolás Antonio |                  |
| Galavis Du Bois, Alan Enrique       |                  |
| Seminario Garbin, Carlo Luca        |                  |
| Soto Kong Requena, Andrés Eduardo   |                  |

# Contenido
1. [**Capítulo I: Introducción.**](#1.) <br>
1.1. [Startup Profile.](#1.1.) <br>
1.1.1. [Descripción del startup.](#1.1.1.)<br>
1.1.2.[Perfiles de los integrantes del equipo.](#1.1.2.)<br>
1.2. [Solution Profile.](#1.2.)<br>
1.2.1. [Antecedentes y Problemática.](#1.2.1.)<br>
1.2.2. [Lean UX Process.](#1.2.2.)<br>
1.2.2.1. [Lean UX Problem Statements.](#1.2.2.1.)<br>
1.2.2.2. [Lean UX Assumptions.](#1.2.2.2.)<br>
1.2.2.3. [Lean UX Hypothesis Statements.](#1.2.2.3.)<br>
1.2.2.4. [Lean UX Canvas.](#1.2.2.4.)<br>
1.3. [Segmentos objetivo.](#1.3.)<br>
2. [**Capítulo II: Requirements Elicitation & Analysis.**](#2.)<br>
2.1. [Competidores.](#2.1.)<br>
2.1.1. [Análisis competitivo.](#2.1.1.)<br>
2.1.2. [Estrategias y tácticas frente a competidores.](#2.1.2.)<br>
2.2. [Entrevistas.](#2.2.)<br>
2.2.1. [Diseño de entrevistas.](#2.2.1.)<br>
2.2.2. [Registro de entrevistas.](#2.2.2.)<br>
2.2.3. [Análisis de entrevistas.](#2.2.3.)<br>
2.3. [Needfinding.](#2.3.)<br>
2.3.1. [User Personas.](#2.3.1.)<br>
2.3.2. [User Task Matrix.](#2.3.2.)<br>
2.3.3. [User Journey Mapping.](#2.3.3.)<br>
2.3.4. [Empathy Mapping.](#2.3.4.)<br>
2.3.5. [As-is Scenario Mapping.](#2.3.5.)<br>
2.4. [Ubiqutous Language.](#2.4.)<br>
3. [**Capítulo III: Requirements Specification.**](#3.)<br>
3.1. [To-Be Scenario Mapping.](#3.1.)<br>
3.2. [User Stories.](#3.2.)<br>
3.3. [Impact Mapping.](#3.3.)<br>
3.4. [Product Backlog.](#3.4.)<br>
4. [**Capítulo IV: Solution Software Design.**](#4.)<br>
4.1. [**Strategic-Level Domain-Driven Design.**](#4.1.)<br>
4.1.1. [**EventStorming.**](#4.1.1.)<br>
4.1.1.1. [**Candidate Context Discovery.**](#4.1.1.1.)<br>
4.1.1.2. [**Domain Message Flows Modeling.**](#4.1.1.2.)<br>
4.1.1.3. [**Bounded Context Canvases.**](#4.1.1.3.)<br>
4.1.2. [**Context Mapping.**](#4.1.2.)<br>
4.1.3. [**Software Architecture.**](#4.1.3.)<br>
4.1.3.1. [**Software Architecture System Landscape Diagram.**](#4.1.3.1.)<br>
4.1.3.2. [**Software Architecture Context Level Diagrams.**](#4.1.3.2.)<br>
4.1.3.3. [**Software Architecture Container Level Diagrams.**](#4.1.3.3.)<br>
4.1.3.4. [**Software Architecture Deployment Diagrams.**](#4.1.3.4.)<br>
4.2. [**Tactical-Level Domain-Driven Design.**](#4.2.)<br>
4.2.1. [**Bounded Context: Crops**](#4.2.1.)<br>
4.2.1.1. [**Domain Layer.**](#4.2.1.1.)<br>
4.2.1.2. [**Interface Layer.**](#4.2.1.2.)<br>
4.2.1.3. [**Application Layer.**](#4.2.1.3.)<br>
4.2.1.4. [**Infrastructure Layer.**](#4.2.1.4.)<br>
4.2.1.5. [**Bounded Context Software Architecture Component Level Diagrams.**](#4.2.1.5.)<br>
4.2.1.6. [**Bounded Context Software Architecture Code Level Diagrams.**](#4.2.1.6.)<br>
4.2.1.6.1. [**Bounded Context Domain Layer Class Diagrams.**](#4.2.1.6.1.)<br>
4.2.1.6.2. [**Bounded Context Database Design Diagram.**](#4.2.1.6.1.)<br>
4.2.2. [**Bounded Context: IAM**](#4.2.2.)<br>
4.2.2.1. [**Domain Layer.**](#4.2.2.1.)<br>
4.2.2.2. [**Interface Layer.**](#4.2.2.2.)<br>
4.2.2.3. [**Application Layer.**](#4.2.2.3.)<br>
4.2.2.4. [**Infrastructure Layer.**](#4.2.2.4.)<br>
4.2.2.5. [**Bounded Context Software Architecture Component Level Diagrams.**](#4.2.2.5.)<br>
4.2.2.6. [**Bounded Context Software Architecture Code Level Diagrams.**](#4.2.2.6.)<br>
4.2.2.6.1. [**Bounded Context Domain Layer Class Diagrams.**](#4.2.2.6.1.)<br>
4.2.2.6.2. [**Bounded Context Database Design Diagram.**](#4.2.2.6.2.)<br>
4.2.3. [**Bounded Context: Mailling**](#4.2.3.)<br>
4.2.3.1. [**Domain Layer.**](#4.2.3.1.)<br>
4.2.3.2. [**Interface Layer.**](#4.2.3.2.)<br>
4.2.3.3. [**Application Layer.**](#4.2.3.3.)<br>
4.2.3.4. [**Infrastructure Layer.**](#4.2.3.4.)<br>
4.2.3.5. [**Bounded Context Software Architecture Component Level Diagrams.**](#4.2.3.5.)<br>
4.2.3.6. [**Bounded Context Software Architecture Code Level Diagrams.**](#4.2.3.6.)<br>
4.2.3.6.1. [**Bounded Context Domain Layer Class Diagrams.**](#4.2.3.6.1.)<br>
4.2.3.6.2. [**Bounded Context Database Design Diagram.**](#4.2.3.6.2.)<br>
4.2.4. [**Bounded Context: Memberships**](#4.2.4.)<br>
4.2.4.1. [**Domain Layer.**](#4.2.4.1.)<br>
4.2.4.2. [**Interface Layer.**](#4.2.4.2.)<br>
4.2.4.3. [**Application Layer.**](#4.2.4.3.)<br>
4.2.4.4. [**Infrastructure Layer.**](#4.2.4.4.)<br>
4.2.4.5. [**Bounded Context Software Architecture Component Level Diagrams.**](#4.2.4.5.)<br>
4.2.4.6. [**Bounded Context Software Architecture Code Level Diagrams.**](#4.2.4.6.)<br>
4.2.4.6.1. [**Bounded Context Domain Layer Class Diagrams.**](#4.2.4.6.1.)<br>
4.2.4.6.2. [**Bounded Context Database Design Diagram.**](#4.2.4.6.2.)<br>
5. [**Capítulo V: Solution UI/UX Design.**](#5.)<br>
5.1. [Style Guidelines.](#4.1.)<br>
5.1.1. [General Style Guidelines.](#4.1.1.)<br>
5.1.2. [Web, Mibuke and IoT Style Guidelines.](#4.1.2.)<br>
5.2. [Information Architecture.](#4.2.)<br>
5.2.1. [Organization Systems.](#4.2.1.)<br>
5.2.2. [Labeling Systems.](#4.2.2.)<br>
5.2.3. [SEO Tags and Meta Tags](#4.2.3.)<br>
5.2.4. [Searching Systems.](#4.2.4.)<br>
5.2.5. [Navigation Systems.](#4.2.5.)<br>
5.3. [Landing Page UI Design.](#4.3.)<br>
5.3.1. [Landing Page Wireframe.](#4.3.1.)<br>
5.3.2. [Landing Page Mock-up.](#4.3.2.)<br>
5.4. [Applications UX/UI Design.](#4.4.)<br>
5.4.1. [Applications Wireframes.](#4.4.1.)<br>
5.4.2. [Applications Wireflow Diagrams.](#4.4.2.)<br>
5.4.3. [Applications Mock-ups.](#4.4.3.)<br>
5.4.4. [Applications User Flow Diagrams.](#4.4.4.)<br>
5.5. [Applications Prototyping.](#4.5.)<br>

# Student Outcome

<table cellpadding="5" cellspacing="0">
  <thead>
    <tr>
      <th>Criterio específico</th>
      <th>Acciones realizadas</th>
      <th>Conclusiones</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Trabaja en equipo para proporcionar liderazgo en forma conjunta</td>
      <td>
      <i>TB1</i><br/>
      <b>Astuyauri Calderón, Jherson David:</b>
      <br/>
      <i>TB1</i><br/>
      <b>Espinoza Rodríguez, Nicolás Antonio:</b>
      <br/>
      <i>TB1</i><br/>
      <b>Galavis Du Bois, Alan Enrique:</b>
      <br/>
      <i>TB1</i><br/>
      <b>Seminario Garbín, Carlo Luca:</b>
      <br/>
      <i>TB1</i><br/>
      <b>Soto Kong Requena, Andrés Eduardo:</b>
      </td>
      <td></td>
    </tr>
    <tr>
    <tr>
      <td>Crea un entorno colaborativo e inclusivo, establece metas, planifica tareas y cumple objetivos. </td>
      <td>
      <i>TB1</i><br/>
      <b>Astuyauri Calderón, Jherson David:</b>
      <br/>
      <i>TB1</i><br/>
      <b>Espinoza Rodríguez, Nicolás Antonio:</b>
      <br/>
      <i>TB1</i><br/>
      <b>Galavis Du Bois, Alan Enrique:</b>
      <br/>
      <i>TB1</i><br/>
      <b>Seminario Garbín, Carlo Luca:</b>
      <br/>
      <i>TB1</i><br/>
      <b>Soto Kong Requena, Andrés Eduardo:</b>
      </td>
      <td></td>
    </tr>
  </tbody>
</table>

<h1 id='1.'>Capítulo I: Introducción</h1>
<h2 id='1.1.'>Startup Profile</h2>
En esta sección se presenta la descripción del startup y los perfiles de los miembros del equipo.
<h3 id='1.1.1.'>Descripción de la Startup</h3>
Integradis es una startup que busca modernizar el proceso de documentación de actividades y automatizar la medición de parámetros ambientales en las fábricas productoras de champiñones del Perú. El equipo identificó que el uso de sensores manuales y mantener una documentación escrita en la industria actual no solo es arcaico e ineficiente, sino que puede llevar a mediciones imprecisas, lo cual impacta directamente en la calidad y cantidad de la producción final. Bajo este contexto, el equipo identificó una oportunidad para brindar una solución IoT que permita llevar un mejor control sobre estos procesos, con el fin de mitigar los errores asociados al factor humano, y de fomentar el registro digital de procesos.
Misión: Agilizar e impulsar la digitalización de la documentación y monitoreo de los principales procesos de las fábricas productoras de champiñones del Perú.
Visión: Dentro de los próximos 6 años, ser reconocidos como un modelo de negocio sostenible, líder en el desarrollo de plataformas que modernicen la cadena de producción de champiñones a nivel nacional.
Valores:

- Adaptabilidad: Estamos siempre dispuestos a adaptarnos a las necesidades de nuestros usuarios, a los cambios del mercado y las nuevas tendencias en el sector de agricultura.
- Confianza: Trabajamos de manera constante para generar confianza y seguridad en todas nuestras actividades.
- Constancia: Nos esforzamos por mantener una constante mejora en la calidad de nuestros servicios.
- Disponibilidad: Contamos con un equipo disponible gran parte del día para atender todas las necesidades, dudas o problemas que tengan nuestros usuarios en los diferentes productos o servicios que ofrecemos.

<h3 id='1.1.2.'>Perfiles de integrantes del equipo</h3>

| Foto | Nombres y apellidos | Código de alumno | Carrera | Descripción |
|----- | --------------------|------------------| --------| ------------|
| <img src="assets/images/chapter_1/team_members/JhersonAstuyauri.jpg" alt="Jherson Astuyauri" width="700" /> | **Jherson David Astuyauri Calderón** | U202218451 | Ingeniería de Software | Hola, soy Jherson Astuyauri. Tengo 20 años y actualmente curso el séptimo ciclo de la carrera de Ingeniería de Software. Elegí esta carrera porque me apasiona la tecnología y su impacto en la evolución del mundo, así como en la mejora de la calidad de vida de las personas. Actualmente, me interesan especialmente las áreas de inteligencia artificial y ciberseguridad. Puedo aportar al equipo con los conocimientos técnicos que he adquirido a lo largo de los cursos previos, además de mi capacidad para trabajar en equipo de manera efectiva, con una actitud proactiva y responsabilidad. |
| | **Nicolás Antonio Espinoza Rodríguez** | U202110278 | Ingeniería de Software | |
| <img src="assets/images/chapter_1/team_members/AlanGalavis.jpg" alt="Alan Galavis" width="700" /> | **Alan Enrique Galavís Du Bois** | U202110223 | Ingeniería de Software | Mi nombre es Alan Galavis, tengo 21 años y actualmente curso el noveno ciclo de la carrera de Ingeniería de Software en la Universidad Peruana de Ciencias Aplicadas. Mi formación académica se ha centrado en el diseño y desarrollo de proyectos de alta calidad, desde simples landing pages hasta aplicaciones web y móviles con RESTful APIs. Para este proyecto puedo aportar con mi capacidad de crear un software eficiente y escalable que brinda las mejores experiencias de usuario. Mi compromiso y conocimientos en gestión de proyectos ágiles me permiten colaborar de manera exitosa en equipos de trabajo. |
| | **Carlo Luca Seminario Garbín** | U20211A475 | Ingeniería de Software | |
| | **Andrés Eduardo Soto Kong Requena** | U202116113 | Ingeniería de Software | |

<h2 id='1.2.'>Solution Profile</h2>
<h3 id='1.2.1.'>Antecedentes y problemática</h3>
A continuación, se presentan las secciones de Antecedentes y Problemática, y Lean UX Process. La primera consta del enunciado de problema y una descripción de los puntos más importantes que debe resolver la solución, del mismo modo se presentan los objetivos y restricciones que delimitan el alcance del proyecto. La segunda sección es el resultado de la ejecución del Lean UX Process sobre el dominio del problema.

#### **What? (¿Qué?)**

**¿Cuál es el problema?**

Actualmente, las fábricas de champiñones del Perú emplean un registro manual de las actividades que realizan. Esta práctica es difícil de mantener, poco sostenible con el medio ambiente y susceptible a ineficiencias relacionadas con errores humanos, así como a la pérdida de documentos físicos. 
Por otro lado, los administradores de dichas empresas no cuentan con un método confiable para recibir en tiempo real los reportes del estado de los cultivos. Como consecuencia, los administradores se ven en la necesidad de realizar con gran frecuencia visitas a las fábricas, las cuales en su mayoría están ubicadas en zonas lejanas.

#### **When? (¿Cuándo?)**

**¿Cuándo sucede el problema?**

El problema está presente al momento de entablar un análisis del estado y evolución de los procesos llevados a cabo en la fábrica. Debido a que los registros están en formato físico, se necesita buscar entre los archivos de la fábrica y revisar individualmente cada uno de los informes, lo cual resulta tedioso dado el volumen extenso de información registrada a lo largo del tiempo. Además, está presente al momento de medir y ajustar los parámetros de las naves de cultivo, ya que, actualmente, los trabajadores deben de utilizar periódicamente sensores manuales para controlar las condiciones ambientales, lo cual está sujeto a errores asociados al factor humano.

#### **Where? (¿Dónde?)**

**¿Dónde surge el problema?**

El problema se manifiesta en las fábricas de champiñones ubicadas a nivel nacional, y, por lo tanto, en cada una de las áreas que la componen (Patio de preparación del compost, búnker, túnel de pasteurización y naves).

#### **Who? (¿Quién?)**

**¿Quiénes están involucrados? ¿Quién lo utilizará?**

Los usuarios del sistema serían los técnicos encargados de la supervisión y cuidado de los cultivos, y los administradores de las fábricas champiñoneras en Perú. Por un lado los administradores de la fábrica utilizarán la plataforma para visualizar las mediciones registradas por sus trabajadores y por el sistema IoT. Por otro lado, los técnicos supervisores registrarán los procesos que no pueden ser medidos a través de sensores ni controlados por medio de actuadores, como el listado de materiales para elaborar el compost, y las actividades realizadas en el patio. Los datos recopilados en la aplicación permitirá que los trabajadores tomen decisiones estratégicas informadas sobre la asignación de recursos, la programación de tareas y la identificación de áreas de mejora en la producción.

#### **Why? (¿Por qué?)**

**¿Cuál es la causa del problema?**

La causa principal del problema es la ausencia de un programa que permita registrar con facilidad y de manera digital las actividades de la fábrica. Excel no se presenta como una alternativa viable, puesto que son pocos los trabajadores de las fábricas de champiñones que cuentan con la experiencia y habilidades necesarias para utilizarlo eficientemente.

#### **How? (¿Cómo?)**

**¿Cómo se utilizará el producto?**

Los técnicos y administradores tendrán la posibilidad de acceder a la aplicación a través de sus dispositivos móviles o desde un navegador. La aplicación móvil será usada por técnicos supervisores para registrar datos en formularios digitales específicos para los procesos que no pueden ser automatizados por sensores y actuadores, como la preparación del sustrato (compost), la siembra o el proceso de pasteurización en el túnel. Los datos se almacenarán en una base de datos segura y se presentarán en gráficos y listas fácil de entendimiento para el usuario cuando éste lo solicite.
Por otro lado, los administradores de las fábricas utilizarán la aplicación web para supervisar de manera remota los informes periódicos registrados por los técnicos y por el sistema IoT, con el objetivo de tener una visión general en tiempo real del estado de la producción.

**¿Cómo lograremos desarrollar la correcta gestión de cultivos de champiñones dentro de la plataforma?**

El proceso de cultivo de champiñones está dividido en cuatro etapas distintas: La preparación de la mezcla del compost en el patio, la cocción de la mezcla en el búnker, la pasteurización del compost en el túnel y la incubación, cobertura, inducción y cosecha de los champiñones en las naves de crecimiento. La aplicación abarca cada una de estas fases y la distingue de manera adecuada. Cabe recalcar que el sistema IoT únicamente se enfocará en la última etapa del cultivo de champiñones, es decir, aquellos procesos que se realizan en las naves de cultivo. Específicamente, se utilizarán sensores IoT para medir la temperatura y humedad del ambiente.
Las fábricas mantienen un seguimiento del estado y progreso de las actividades realizadas en cada una de las fases de cultivo, por ello, es fundamental que los técnicos supervisores utilicen nuestra aplicación para presentar informes periódicos correspondientes a sus labores. La aplicación, a su vez, permitirá visualizar reportes estadísticos para evaluar el rendimiento y la eficiencia de cada fase del proceso de producción de champiñones.  

#### **How much? (Cuánto)**

**¿Cuál es la magnitud del problema?**

Según Agro Perú (2023), en el año 2022, el Perú exportó 850 toneladas de champiñones secos por un valor de USD 7,1 millones. Ello representó un aumento del 11 % en volumen y 4 % en valor más que en el año 2021. Estos datos indican que el número de exportaciones aparenta ser próspero, lo que confirma la solidez del mercado seleccionado. 
Sin embargo, una encuesta realizada por Cajo y Rosales (2022) revela que, de las 58 empresas agroindustriales peruanas, el 33.9% no administra ni actualiza de manera adecuada el inventario, las características y los cambios en los cultivos. Por otro lado, el resto de las empresas aún realiza estos procesos de forma manual y, por tanto, con márgenes de error muy altos por el factor humano. Por esta razón, resulta necesario el acceso a un software amigable (aplicación móvil) con un proceso de automatización adecuado para agilizar y monitorear el registro de las fases involucradas en la producción de cultivos de estas industrias.
De acuerdo con The Yield Lab (2019), el reto para los startups de la industria agrícola es alcanzar soluciones para la producción de alimentos de una forma más sustentable y eficiente debido al incremento de la demanda en Latinoamérica. Es ahí que se ve implicada Greenhouse como alternativa de solución.

**¿Qué porcentaje del personal de la industria champiñonera se verá beneficiado por el servicio?**

El sistema puede ser utilizado por múltiples técnicos, supervisores y administradores, quiénes incorporan al personal de las fábricas dedicadas a la producción de champiñones. No hay un límite preciso en cuanto al número de usuarios; sin embargo, se estima que alrededor del 35% de usuarios dentro de este sector se verán beneficiados de la implementación de la aplicación.

<h3 id='1.2.2.'>Lean UX Process</h3>
<h4 id='1.2.2.1.'>Lean UX Problem Statements</h4>
<h4 id='1.2.2.2.'>Lean UX Assumptions</h4>
<h4 id='1.2.2.3.'>Lean UX Hypothesis Statements</h4>
<h4 id='1.2.2.4.'>Lean UX Canvas</h4>
<h2 id='1.3.'>Segmentos objetivo</h2>

<h1 id='2.'>2. Capítulo II: Requirements Elicitation & Analysis.</h1>
<h2 id='2.1.'>2.1. Competidores.</h2>
<h3 id='2.1.1.'>2.1.1. Análisis competitivo.</h3>
<h3 id='2.1.2.'>2.1.2. Estrategias y tácticas frente a competidores.</h3>
<h2 id='2.2.'>2.2. Entrevistas.</h2>
<h3 id='2.2.1.'>2.2.1. Diseño de entrevistas.</h3>
<h3 id='2.2.2.'>2.2.2. Registro de entrevistas.</h3>
<h3 id='2.2.3.'>2.2.3. Análisis de entrevistas.</h3>
<h2 id='2.3.'>2.3. Needfinding.</h2>
<h3 id='2.3.1.'>2.3.1. User Personas.</h3>
<h3 id='2.3.2.'>2.3.2. User Task Matrix.</h3>
<h3 id='2.3.3.'>2.3.3. User Journey Mapping.</h3>
<h3 id='2.3.4.'>2.3.4. Empathy Mapping.</h3>
<h3 id='2.3.5.'>2.3.5. As-is Scenario Mapping.</h3>
<h2 id='2.4.'>2.4. Ubiqutous Language.</h2>
El lenguaje ubicuo permite que las personas del negocio, incluso aquellas sin conocimientos técnicos, comprendan mejor la plataforma Greenhouse. Por ello, a continuación, se presentan una serie de términos en inglés frecuentemente utilizados en la aplicación, junto con sus definiciones en castellano. 

- Company/Compañía: Empresa registrada en la plataforma greenhouse que tiene asociado a su información a los siguientes tipos de usuarios:
  - Factory Administrator/Administrador de la fábrica: Encargado de supervisar a los Técnicos Supervisores y evaluar las estadísticas de la empresa.
  - Technician/Técnico supervisor: Empleado encargado de supervisar el proceso de cultivo de champiñones y escribir los registros
- Crop/Cultivo: Conglomerado de récords y fases que componen a un cultivo específico
  - Crop ID/Cultivo ID: Identificador único de un cultivo.
- Logs: Conjunto de registros realizados para un determinado cultivo en una determinada fase
- Membership/Plan de suscripción: Suscripción que da acceso a la plataforma Greenhouse.
- Phase/Fase: Etapas del proceso del cultivado de un cultivo, las cuales son los siguientes
  - Formula/Insumos: Primera fase de un cultivo
  - Preparation area/Patio: Segunda fase de un cultivo
  - Bunker/Búnker: Tercera fase de un cultivo
  - Tunnel/Túnel: Cuarta fase de un cultivo
  - Incubation/Incubación: Quinta fase de un cultivo
  - Casing/Cobertura: Sexta fase de un cultivo
  -	Induction/Inducción: Séptima fase de un cultivo
  -	Harvest/Cosecha: Octava fase de un cultivo
  -	Author/Autor: Usuario que realizó el registro
  - Grow Room/Nave: Estructuras industriales similares a un invernadero donde se cultivan champiñones
- Record/Registro: Entrada de datos en determinado momento durante una fase de un cultivo
  - Record ID/Registro ID: Identificador único de un registro
- IoT: concepto que describe la interconexión de dispositivos físicos a través de internet, permitiendo que recopilen, compartan y procesen datos de forma automática.
- Sensor: dispositivo que recopila datos del entorno, como temperatura, humedad, entre otros, y los transmite a través de una red para ser procesados o analizados por otros dispositivos o sistemas.
- Actuador: Dispositivo que recibe señales o comandos de un sistema y realiza una acción física en el entorno, como encender un motor, abrir una válvula o ajustar la temperatura, como respuesta a los datos procesados por sensores u otros dispositivos.

<h1 id='4.'>4. Capítulo IV: Solution Software Design</h1>
<h2 id='4.1.'>4.1. Strategic-Level Domain-Driven Design.<br>
<h3 id='4.1.1.'>4.1.1. EventStorming.<br>
<h4 id='4.1.1.1.'>4.1.1.1. Candidate Context Discovery.<br>
<h4 id='4.1.1.2.'>4.1.1.2. Domain Message Flows Modeling.<br>
<h4 id='4.1.1.3.'>4.1.1.3. Bounded Context Canvases.<br>
<h3 id='4.1.2.'>4.1.2. Context Mapping.</h3>
<h3 id='4.1.3.'>4.1.3. Software Architecture.</h3>
<h4 id='4.1.3.1.'>4.1.3.1. Software Architecture System Landscape Diagram.</h4>

El diagrama de landscape es útil para identificar los usuarios y sistemas que interactúan con el programa propuesto, además de proporcionar una visión general de los servicios involucrados. Sin embargo, debido a su enfoque en la arquitectura general, no muestra con detalle las diferencias específicas entre una arquitectura basada en microservicios y una arquitectura monolítica.

<img src='assets/images/chapter_4/strategic_ddd/system_landscape_diagram.png' alt='Software Architecture System Landscape Diagram' />

<h4 id='4.1.3.2.'>4.1.3.2. Software Architecture Context Level Diagrams.</h4>

El diagrama de contexto es de utilidad para identificar los usuarios y sistemas que interactúan con el programa propuesto, sin embargo, debido al poco detalle que presenta, no muestra ninguna diferencia de una arquitectura basada en microservicios con una arquitectura monolítica.

<img src='assets/images/chapter_4/strategic_ddd/context_diagram.png' alt='Software Architecture Context Level Diagrams' />

<h4 id='4.1.3.3.'>4.1.3.3. Software Architecture Container Level Diagrams.</h4>

El diagrama de contenedores presentado a continuación representa cómo interactúan los usuarios y sistemas con los principales componentes del sistema “Greenhouse”, entre los cuales cabe destacar el API gateway, el Identity and Access Management, y los servicios de personas, cultivos, membresías y un servicio por separado para manejar la parte IoT. La separación de estos servicios, cada uno con sus bases de datos independientes, evidencian la intención de desarrollar un producto basado en microservicios.

<img src='assets/images/chapter_4/strategic_ddd/container_diagram.png' alt='Software Architecture Context Level Diagrams' />

<h4 id='4.1.3.4.'>4.1.3.4. Software Architecture Deployment Diagrams.</h4>

<img src='assets/images/chapter_4/strategic_ddd/deployment_diagram.png' alt='Software Architecture Context Level Diagrams' />

<h2 id='4.2.'>4.2. Tactical-Level Domain-Driven Design.</h2>
<h3 id='4.2.2.'>4.2.2. Bounded Context: IAM</h3>
Este bounded context se enfoca en las clases y capas relacionadas con los usuarios de la aplicación, sus roles y sus credenciales. A continuación, se detallan los principales componentes de este contexto.
<h4 id='4.2.2.1.'>4.2.2.1. Domain Layer.<h4>

- Users: Esta Clase representa un usuario, registrado en greenhouse. Contiene los atributos rol, username y password.

<h4 id='4.2.2.2.'>4.2.2.2. Interface Layer.<h4>
Controller:

- Users: Define un controlador 'UsersController' en NestJS que gestiona las operaciones de usuario. Utiliza un servicio 'UserService' para manejar comandos de creación, actualización, eliminación y búsqueda de usuarios. Los métodos del controlador transforman los DTOs recibidos en comandos y devuelven resultados apropiados, como listas de usuarios o detalles de un usuario específico.

<h4 id='4.2.2.3.'>4.2.2.3. Application Layer.<h4>

**Command Handlers:**

- create-user: Define una clase que implementa 'ICommandHandler<CreateUserCommand>', con un constructor que inyecta dependencias para crear y guardar usuarios. El método 'execute' verifica si ya existe un usuario con el nombre de usuario proporcionado y, si no, crea un nuevo usuario usando una fábrica y lo guarda en el repositorio.
- delete-user: Define una clase que implementa 'ICommandHandler<DeleteUserCommand>', con un constructor que inyecta repositorios para buscar y eliminar usuarios. El método 'execute' busca un usuario por nombre de usuario, lanza una excepción si no existe y, si lo encuentra, lo elimina usando el repositorio correspondiente.
- update-user: Define una clase que implementa 'CommandHandler<UpdateUserCommand>', con un constructor que inyecta repositorios para buscar y guardar usuarios. El método 'execute' busca un usuario por nombre de usuario, lanza excepciones si no existe o si el rol es inválido, y actualiza el rol y la contraseña del usuario antes de guardarlo.

**Facades:**

- user-facade: Define un servicio 'UsersFacadeService' en NestJS que utiliza el patrón CQRS, inyectando 'CommandBus' y 'QueryBus'. Proporciona métodos para crear un usuario, comparar una contraseña con un nombre de usuario, y obtener el rol e ID de un usuario por su nombre de usuario, utilizando comandos y consultas para manejar la lógica.

**Ports:**

- create-user: Define una clase abstracta 'CreateUserRepository' que especifica un método 'save', el cual debe ser implementado por las clases concretas para guardar un objeto 'User' y devolverlo como una promesa.
- find-user: Define una clase abstracta 'FindUsersRepository' que especifica métodos para buscar usuarios: 'findAll', que devuelve una lista de usuarios, y 'findByUsername', que busca un usuario por su nombre de usuario y devuelve el usuario o 'undefined'.
- remove-user: Define una clase abstracta 'RemoveUserRepository' que especifica un método 'remove', el cual debe ser implementado por las clases concretas para eliminar un objeto User' y devolverlo como una promesa.
- save-user: Define una clase abstracta 'SaveUserRepository' que especifica un método 'save, el cual debe ser implementado por las clases concretas para guardar un objeto 'User' y devolverlo como una promesa.

**Queries Handler:**

- compare-password: Define un manejador de consulta 'ComparePasswordForUsernameQueryHandler' que implementa 'IQueryHandler'. Inyecta repositorios para buscar usuarios y un servicio de hashing. El método 'execute' busca un usuario por nombre de usuario y compara la contraseña proporcionada con la almacenada, devolviendo 'true' o 'false' según el resultado.

- get-user-by-username: Define un manejador de consulta 'GetUserByUsernameQueryHandler' que implementa 'IQueryHandler'. Inyecta un repositorio para buscar usuarios y su método 'execute' busca un usuario por nombre de usuario, lanzando una excepción si no existe, y devolviendo el objeto 'User' encontrado.
- get-users: Define un manejador de consulta 'GetUsersQueryHandler' que implementa 'IQueryHandler'. Inyecta un repositorio para buscar usuarios y su método 'execute' devuelve una lista de todos los usuarios al llamar a 'findAll' en el repositorio.

<h4 id='4.2.2.4.'>4.2.2.4. Infrastructure Layer.<h4>

**Entities:**

- User: Define una entidad 'UserEntity' para la tabla 'users' en TypeORM, con propiedades para ID, nombre de usuario (único y en minúsculas), contraseña y rol (con un valor por defecto).
Enums:
- Role: Define un enum Role con dos posibles valores: Regular y Admin, representando los roles de usuario en la aplicación.
Mapper:
- User: Define una clase 'UserMapper' que convierte entre una entidad de usuario ('UserEntity') y un objeto de dominio ('User'), proporcionando métodos para mapear hacia el dominio y hacia la persistencia en la base de datos.
Repositories:
- create-user: Define un constructor que inyecta un repositorio de 'UserEntity', y un método 'save' que convierte un objeto de dominio 'User' a una entidad, la guarda en la base de datos y devuelve el objeto de dominio correspondiente.
- find-user: Define un constructor que inyecta un repositorio de 'UserEntity' y dos métodos: 'findAll', que recupera todos los usuarios de la base de datos y los convierte a objetos de dominio, y 'findByUsername', que busca un usuario por su nombre de usuario y lo convierte a un objeto de dominio si existe.
- remove-user: Define un constructor que inyecta un repositorio de 'UserEntity' y un método 'remove' que convierte un objeto de dominio 'User' a una entidad, la elimina de la base de datos y devuelve el objeto de dominio correspondiente.
- save-user: Define un constructor que inyecta un repositorio de 'UserEntity' y un método 'save' que convierte un objeto de dominio 'User' a una entidad, la guarda en la base de datos y devuelve el objeto de dominio resultante.

<h4 id='4.2.2.5.'>4.2.2.5. Bounded Context Software Architecture Component Level Diagrams.<h4>

A continuación, se presenta el diagrama de componentes asociado al bounded context IAM

<img src='assets/images/chapter_4/iam/iam_component_diagram.png' alt='IAM Component Level Diagram' />

<h4 id='4.2.2.6.'>4.2.2.6. Bounded Context Software Architecture Code Level Diagrams.<h4>

<h5 id='4.2.2.6.1.'>4.2.2.6.1. Bounded Context Domain Layer Class Diagrams.<h5>

A continuación, se presenta el diagrama de clases asociado al bounded context Usuario, el cual incluye las entidades User, Role y UserFactory, así como los manejadores de comandos para la creación, actualización y eliminación de usuarios. Este diagrama resulta de utilidad para expresar visualmente la estructura del sistema en cuanto a clases, atributos, métodos y relaciones.

<img src='assets/images/chapter_4/iam/iam_class_diagram.png' alt='IAM Class Diagram' />

<h5 id='4.2.2.6.2.'>4.2.2.6.2. Bounded Context Database Design Diagram.</h5>

<img src='assets/images/chapter_4/iam/iam_database_diagram.png' alt='IAM Database Diagram' />

<table cellpadding="5" cellspacing="0">
  <thead>
    <tr>
      <th>Nombre del atributo</th>
      <th>Descripción del atributo</th>
      <th>Tipo de dato del atributo</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>Identificador del usuario, UUID, primary key</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>username</td>
      <td>Apodo o nombre con el cual el usuario ingresará a la aplicación</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>password</td>
      <td>Contraseña del usuario</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>role</td>
      <td>Rol del usuario dentro de la aplicación</td>
      <td>varchar(255)</td>
    </tr>
  <tbody>
</table>

<h3 id='4.2.3.'>4.2.3. Bounded Context: Mailling</h3>
Este bounded context se enfoca en las clases y capas relacionadas con el envío de correos de notificación sobre algún evento importante de notificar relacionado con el proceso de los cultivos de champiñones mediante el uso del servicio externo de Resend AutoML de Azure. A continuación, se detallan los principales componentes de este contexto.

<h4 id='4.2.3.1.'>4.2.3.1. Domain Layer.<h4>

- MaIl: Esta clase representa el correo electrónico que pertenece a un usuario y contiene atributos como id, userId, userHandle, address y domain. Asimismo, cuenta con el método toString que permite unir el address y domain para obtener el correo formateado. 
  
- MailTemplate<T:>: Esta clase genérica representa una plantilla de correo electrónico que contiene como atributos id, title, body, y dispone un método que permite obtener el template dado un payload del tipo T el cuál permitirá personalizar más la información que se utilizará.
  
- SendEvent: Esta clase representa el evento de envío de correo electrónico que contiene atributos como id, mail, template, createdAt y name.


<h4 id='4.2.3.2.'>4.2.3.2. Interface Layer.<h4>
EmailController: Maneja las solicitudes relacionadas con el envío de correos y la gestión de plantilla y dispone de los siguientes métodos:

- createMail(userHandle: string, address: string, domain: string): Mail
- createTemplate(id: string, title: string, body: string): MailTemplate
- sendMail(mail: Mail, template: MailTemplate): SendEvent
- getMailHistory(userId: string): SendEvent[]


<h4 id='4.2.3.3.'>4.2.3.3. Application Layer.<h4>

**Command Handlers:**

Command Handlers:
-	create-mail: Crea una nueva instancia de Mail.
- create-template: Crea una nueva instancia de MailTemplate.
-	send-mail: Utiliza ResendFacade para enviar un correo y crea un nuevo SendEvent.

**Queries Handler:**

-	get-mail-by-id: Obtiene un Mail específico por su ID.
-	get-template-by-id: Obtiene un MailTemplate específico por su ID.
-	get-send-events-by-user: Obtiene un array de SendEvent para un usuario específico.

<h4 id='4.2.3.4.'>4.2.3.4. Infrastructure Layer.<h4>

**Repositories:**

-	create-mail: Persiste una nueva instancia de Mail en la base de datos.
-	create-template: Persiste una nueva instancia de MailTemplate en la base de datos.
-	create-send-event: Persiste un nuevo SendEvent en la base de datos.
-	find-mail: Busca y devuelve instancias de Mail basadas en diversos criterios.
-	find-template: Busca y devuelve instancias de MailTemplate basadas en diversos criterios.
-	find-send-events: Busca y devuelve SendEvents basados en diversos criterios.

**Services:**

-	ResendFacade: Interactúa con el servicio externo de Resend para gestionar el envío de correos.

**Mappers:**

-	mail-mapper: Convierte entre objetos de dominio Mail y su representación en la capa de persistencia.
-	template-mapper: Realiza el mapeo entre objetos de dominio MailTemplate y su versión persistente.
-	send-event-mapper: Mapea objetos SendEvent entre la capa de dominio y la de persistencia.


<h4 id='4.2.4.5.'>4.2.4.5. Bounded Context Software Architecture Component Level Diagrams.<h4>

A continuación, se presenta el diagrama de componentes asociado al bounded context Mailling

<img src='assets/images/chapter_4/mailing/mailling_component_diagram.png' alt='Mailling Component Level Diagram' />

<h4 id='4.2.4.6.'>4.2.4.6. Bounded Context Software Architecture Code Level Diagrams.<h4>

<h5 id='4.2.4.6.1.'>4.2.2.4.1. Bounded Context Domain Layer Class Diagrams.<h5>

A continuación, se presenta el diagrama de clases del microservicio encargado de la gestión de notificaciones por correo electrónico. Este diseño incluye las entidades Mail y MailTemplate, las cuales son procesadas a través de la fachada (ResendFacade), que abstrae la interacción con el servicio de Resend, encargado de ejecutar la lógica de envío de correos. Además, se ha implementado un mecanismo para registrar los eventos asociados al envío de correos, con el fin de garantizar una trazabilidad completa, permitiendo un monitoreo detallado del estado de los envíos y de los destinatarios involucrados, optimizando así el seguimiento y análisis del flujo de notificaciones.

<img src='assets/images/chapter_4/mailing/mailling_class_diagram.png' alt='Mailling Class Diagram' />

<h5 id='4.2.4.6.2.'>4.2.4.6.2. Bounded Context Database Design Diagram.</h5>

<img src='assets/images/chapter_4/mailing/mailling_database_diagram.png' alt='Mailling Database Diagram' />

<table cellpadding="5" cellspacing="0">
  <thead>
    <tr>
      <th>Nombre del atributo</th>
      <th>Descripción del atributo</th>
      <th>Tipo de dato del atributo</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>Identificador del mail, UUID, primary key</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>user_id</td>
      <td>Identificador del usuario, UUID</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>user_handle</td>
      <td>Apodo preferido para el usuario a usar en los correos</td>
      <td>varchar(32)</td>
    </tr>
    <tr>
      <td>address</td>
      <td>Dirección del correo electrónico</td>
      <td>varchar(24)</td>
    </tr>
    <tr>
      <td>domain</td>
      <td>Dominio del correo electrónico</td>
      <td>varchar(24)</td>
    </tr>
  </tbody>
</table>

<table cellpadding="5" cellspacing="0">
  <thead>
    <tr>
      <th>Nombre del atributo</th>
      <th>Descripción del atributo</th>
      <th>Tipo de dato del atributo</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>Identificador del template, UUID, primary key</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>title</td>
      <td>Título o asunto que tendrá el correo</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>body</td>
      <td>Cuerpo del correo que tendrá todo el contenido base que se enviará al usuario</td>
      <td>varchar(32)</td>
    </tr>
  </tbody>
</table>

<table cellpadding="5" cellspacing="0">
  <thead>
    <tr>
      <th>Nombre del atributo</th>
      <th>Descripción del atributo</th>
      <th>Tipo de dato del atributo</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>Identificador del evento de envío de mail, UUID, primary key</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>mail_id</td>
      <td>Identificador del mail, UUID, foreign key</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>mail_template_id</td>
      <td>Identificador del template, UUID, foreign key</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>name</td>
      <td>Nombre personalizado que se le puede dar al evento</td>
      <td>varchar(32)</td>
    </tr>
    <tr>
      <td>created_at</td>
      <td>Timestamp del momento en el que el evento fue creado</td>
      <td>timestamp</td>
    </tr>
  </tbody>
</table>

<h3 id='4.2.4.'>4.2.3. Bounded Context: Memberships</h3>
En esta sección, el equipo presenta las clases identificadas y las detalla a manera de diccionario
A continuación, se presentan las clases identificadas

- **Memberships:** <br> **Propósito:** Esta clase representa a una membresía ligada a un empresa en el sistema. Incluye detalles del nivel de la membresía, su vigencia y detalles de su estado. <br> Atributos: <br> - **id:** string, Identificador único de la membresía <br> -**companyId:** string, Identificador único de la empresa que posee la membresía <br> - **membershipLevel:** MembershipLevel, Objeto con el detalle del nivel de la membresía <br> - **membershipPayment:** MembershipPayment, Objeto con el detalle de la transacción con la cual se adquirió la membresía <br> - **startDate:** DateTime, Fecha y hora de inicio de la membresía <br> - **endDate:** DateTime, Fecha y hora de expiración de la membresía <br> - **status:** string, Estado actual de la membresía (active, inactive, expired)

- **Métodos:** <br> - **activate():** void, Activa la membresía <br> - **renew(newEndDate: DateTime):** void, Renueva la membresía extendiendo su vigencia. <br> - **expire():** void, Marca la membresía como expirada

- **Relaciones:** <br> - **MembershipLevel:** La clase Memberships utiliza la clase MembershipLevel para la renovación y expiración de membresías, dado que la vigencia de la membresía varía según su grado. <br> -  **MembershipPayment:**  La clase Memberships utiliza la clase MembershipPayment para verificar el estado de las transacciones que conciernen a las membresías, además de efectuar el cobro de renovaciones.

- **MembershipLevel:** <br> - **Propósito:** Define los distintos niveles de membresía, asimismo los permisos y beneficios que estas otorgan. <br> - **Atributos:** <br> -**id:** string, Identificador único del nivel de membresía <br> - **name:** string, Nombre del nivel de membresía <br> - **benefits:** string[], Lista de beneficios asociados al nivel de la membresía <br> - **privileges:** string[], Lista de privilegios asociados al nivel de la membresía <br> - **Métodos:** <br> - **getBenefit(benefit: string):** string, Devuelve la información o grado de un beneficio <br> - **updateBenefits(newBenefits: string[]):** void, Actualiza los beneficios del nivel de membresía <br> - **isPrivilegeAssigned(privilege: string):** bool, Verifica si el nivel de membresía contiene el privilegio consultado <br> - **Relaciones:** <br> - **Memberships:** La clase Memberships utiliza la clase MembershipLevel para la renovación y expiración de membresías, dado que la vigencia de la membresía varía según su grado.

- **MembershipPayment:** <br> - **Propósito:** Registra las transacciones relacionadas a adquisiciones de membresías. <br> - **Atributos:** <br> - **id:** string, Identificador único del pago <br> - **membershipId:** string, Identificador de la membresía asociada <br> - **amount:** number, Monto del pago asociado a la transacción <br> - **paymentDate:** Date, Fecha del pago <br> - **paymentMethod:** string, Método de pago <br> - **Métodos:** <br> - **registerPayment(amount: number, method: string):** void, Registra un nuevo pago para una membresía <br> - **Relaciones:** <br> - **Memberships:** La clase Memberships utiliza la clase MembershipPayment para verificar el estado de las transacciones que conciernen a las membresías, además de efectuar el cobro de renovaciones.

<h4 id='4.2.4.1.'>4.2.4.1. Domain Layer.<h4>

La clase Memberships representa una parte importante del core de la aplicación. El grado de esta membresía condiciona los límites de uso de las empresas que utilizan el software mediante la cantidad de cultivos activos a la vez, los permisos que tienen sus administradores y el nivel de control sobre sus empleados que podrán mantener dentro de la plataforma.

- Una empresa puede adquirir una única membresía durante su vigencia, la cual puede aumentar o disminuir de grado según sus necesidades.
- Los permisos de membresía de todos los empleados trabajando bajo una empresa son los mismos sin importar su rol o distinción en la aplicación.
- La empresa obtiene 5 días de prórroga de una membresía expirada para gestionar adecuadamente la extensión o fin del término de los permisos correspondientes.

- **MembershipsPayment**: El pago de la membresía y recibo existe independientemente de la vigencia de la propia membresía. Esto es importante de considerar cuando surge la necesidad del administrador de revisar el historial de adquisiciones de una determinada empresa.

- **MembershipLevel**: Cada membresía tiene un grado o nivel de beneficios que esta confiere a la empresa beneficiada. Este nivel está ligado a la entidad de membresía y es consultado cuando algún usuario de la aplicación, perteneciente a una empresa, realiza ciertas acciones.

- **Memberships**: Se considera a una membresía como un aggregate debido a la relación que mantiene con las clases que conciernen el nivel de membresía y su pago. La membresía se encarga de verificar su propio tiempo de vigencia, otorgar beneficios y orquestar eventos según los privilegios de la empresa favorecida.

- **MembershipsPaymentFactory**: Abstrae la complejidad y la lógica de creación de pagos o recibos de las transacciones de membresías.

- **BillingService**: Servicio encargado de conectarse con el sistema externo de pagos, el cual tiene la función de cobrar el precio de la membresía mediante el método de pago especificado por la empresa.

- **MembershipsRepository**: Interfaz que define los métodos a utilizar para la conexión a la base de datos.

<h4 id='4.2.4.2.'>4.2.4.2. Interface Layer.<h4>
En esta sección se presentan las clases que forman parte de la capa de interfaz/presentación para el bounded context de membresías.
  
**Controllers:**
- **MembershipsController:** Maneja la creación, eliminación, búsqueda de permisos y actualización de estados de las membresías al nivel de la API. Es el método llamado cuando se realizan las consultas al microservicio de memberships.

<h4 id='4.2.4.3.'>4.2.4.3. Application Layer.<h4>

En esta sección se presentan las clases que manejan los flujos del proceso de membresías en el negocio.  

CommandHandlers: 

- create-membership: Clase encargada de crear una nueva membresía.  
- renew-membership: Clase encargada de actualizar el tiempo de expiración de una membresía  
- expire-membership: Actualiza el estado de una membresía a expirada.  
- update-benefit: Actualiza algún beneficio de un determinado nivel de membresía.  
- create-payment: Crea un nuevo registro de pago de membresía  

QueryHandlers:  

- get-membership-benefits-by-level: Obtiene todos los beneficios de un determinado nivel de membresía  
- get-membership-by-company-id: Obtiene detalles de la membresía adquirida por una determinada empresa.  


<h4 id='4.2.4.4.'>4.2.4.4. Infrastructure Layer.<h4>

En esta sección se presentan las clases que acceden a servicios externos en el bounded context de membresías. 

Repositories (Class):

MembershipRepository:
- create-membership: Crea una nueva membresía asignada a una empresa en la base de datos.  
- update-membership: Actualiza los detalles respecto a una membresía dentro de la base de datos.  
- get-membership-by-company-id: Obtiene una membresía de la base de datos según el id de la compañía.  

MembershipLevelRepository:
- update-benefit: Actualiza la lista de beneficios de un determinado nivel de membresía.  
- get-membership-benefits-by-level: Obtiene la lista de beneficios para el nivel de membresía.  

MembershipPaymentRepository:
- create-payment: Crea un nuevo pago en la base de datos correspondiente a una adquisición de membresía.  

Mappers:
- MembershipDao: Realiza el mapeo o conversión entre el objeto de membresía del dominio y el objeto que representa los datos ingresados a la persistencia.  
- MembershipLevelDao: Realiza el mapeo o conversión entre el objeto de beneficios de la membresía del dominio y el objeto que representa los datos ingresados a la persistencia.  
- MembershipPaymentDao: Realiza la conversión entre el objeto de pago de membresía del dominio y el objeto persistence que ingresa la información a la base de datos.  


<h4 id='4.2.4.5.'>4.2.4.5. Bounded Context Software Architecture Component Level Diagrams.<h4>

A continuación, se presenta el diagrama de componentes asociado al bounded context Mailling

<img src='assets/images/chapter_4/mailing/mailling_component_diagram.png' alt='Mailling Component Level Diagram' />

<h4 id='4.2.4.6.'>4.2.4.6. Bounded Context Software Architecture Code Level Diagrams.<h4>

<h5 id='4.2.4.6.1.'>4.2.2.4.1. Bounded Context Domain Layer Class Diagrams.<h5>

A continuación, se presenta el diagrama de clases del microservicio encargado de la gestión de notificaciones por correo electrónico. Este diseño incluye las entidades Mail y MailTemplate, las cuales son procesadas a través de la fachada (ResendFacade), que abstrae la interacción con el servicio de Resend, encargado de ejecutar la lógica de envío de correos. Además, se ha implementado un mecanismo para registrar los eventos asociados al envío de correos, con el fin de garantizar una trazabilidad completa, permitiendo un monitoreo detallado del estado de los envíos y de los destinatarios involucrados, optimizando así el seguimiento y análisis del flujo de notificaciones.

<img src='assets/images/chapter_4/mailing/mailling_class_diagram.png' alt='Mailling Class Diagram' />

<h5 id='4.2.4.6.2.'>4.2.4.6.2. Bounded Context Database Design Diagram.</h5>

<img src='assets/images/chapter_4/mailing/mailling_database_diagram.png' alt='Mailling Database Diagram' />

<table cellpadding="5" cellspacing="0">
  <thead>
    <tr>
      <th>Nombre del atributo</th>
      <th>Descripción del atributo</th>
      <th>Tipo de dato del atributo</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>Identificador del mail, UUID, primary key</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>user_id</td>
      <td>Identificador del usuario, UUID</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>user_handle</td>
      <td>Apodo preferido para el usuario a usar en los correos</td>
      <td>varchar(32)</td>
    </tr>
    <tr>
      <td>address</td>
      <td>Dirección del correo electrónico</td>
      <td>varchar(24)</td>
    </tr>
    <tr>
      <td>domain</td>
      <td>Dominio del correo electrónico</td>
      <td>varchar(24)</td>
    </tr>
  </tbody>
</table>

<table cellpadding="5" cellspacing="0">
  <thead>
    <tr>
      <th>Nombre del atributo</th>
      <th>Descripción del atributo</th>
      <th>Tipo de dato del atributo</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>Identificador del template, UUID, primary key</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>title</td>
      <td>Título o asunto que tendrá el correo</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>body</td>
      <td>Cuerpo del correo que tendrá todo el contenido base que se enviará al usuario</td>
      <td>varchar(32)</td>
    </tr>
  </tbody>
</table>

<table cellpadding="5" cellspacing="0">
  <thead>
    <tr>
      <th>Nombre del atributo</th>
      <th>Descripción del atributo</th>
      <th>Tipo de dato del atributo</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>id</td>
      <td>Identificador del evento de envío de mail, UUID, primary key</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>mail_id</td>
      <td>Identificador del mail, UUID, foreign key</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>mail_template_id</td>
      <td>Identificador del template, UUID, foreign key</td>
      <td>varchar(255)</td>
    </tr>
    <tr>
      <td>name</td>
      <td>Nombre personalizado que se le puede dar al evento</td>
      <td>varchar(32)</td>
    </tr>
    <tr>
      <td>created_at</td>
      <td>Timestamp del momento en el que el evento fue creado</td>
      <td>timestamp</td>
    </tr>
  </tbody>
</table>

